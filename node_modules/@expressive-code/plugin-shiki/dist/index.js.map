{"version":3,"sources":["../src/index.ts","../src/highlighter.ts","../src/languages.ts","../src/transformers.ts"],"sourcesContent":["import { ExpressiveCodeLine, ExpressiveCodePlugin, ExpressiveCodeTheme, InlineStyleAnnotation } from '@expressive-code/core'\nimport type { ThemedToken, ShikiTransformer } from 'shiki'\nimport { bundledThemes } from 'shiki'\nimport { ensureLanguagesAreLoaded, ensureThemeIsLoaded, getCachedHighlighter, runHighlighterTask } from './highlighter'\nimport type { LanguageInput } from './languages'\nimport { runPreprocessHook, runTokensHook, validateTransformers } from './transformers'\n\nexport interface PluginShikiOptions {\n\t/**\n\t * A list of additional languages that should be available for syntax highlighting.\n\t *\n\t * You can pass any of the language input types supported by Shiki, e.g.:\n\t * - `import('./some-exported-grammar.mjs')`\n\t * - `async () => JSON.parse(await fs.readFile('some-json-grammar.json', 'utf-8'))`\n\t *\n\t * See the [Shiki documentation](https://shiki.style/guide/load-lang) for more information.\n\t */\n\tlangs?: LanguageInput[] | undefined\n\t/**\n\t * Allows defining alias names for languages. The keys are the alias names,\n\t * and the values are the language IDs to which they should resolve.\n\t *\n\t * The values can either be bundled languages, or additional languages\n\t * defined in `langs`.\n\t *\n\t * @example { 'mjs': 'javascript' }\n\t */\n\tlangAlias?: Record<string, string> | undefined\n\t/**\n\t * By default, the additional languages defined in `langs` are only available in\n\t * top-level code blocks contained directly in their parent Markdown or MDX document.\n\t *\n\t * Setting this option to `true` also enables syntax highlighting when a fenced code block\n\t * using one of your additional `langs` is nested inside an outer `markdown`, `md` or `mdx`\n\t * code block. Example:\n\t *\n\t * `````md\n\t * ````md\n\t * This top-level Markdown code block contains a nested `my-custom-lang` code block:\n\t *\n\t * ```my-custom-lang\n\t * This nested code block will only be highlighted using `my-custom-lang`\n\t * if `injectLangsIntoNestedCodeBlocks` is enabled.\n\t * ```\n\t * ````\n\t * `````\n\t */\n\tinjectLangsIntoNestedCodeBlocks?: boolean | undefined\n\t/**\n\t * An optional list of Shiki transformers.\n\t *\n\t * **Warning:** This option is experimental and only supports a very limited subset of\n\t * transformer features. Currently, only the `preprocess` and `tokens` hooks are supported,\n\t * and only if they do not modify the code block's text.\n\t *\n\t * Trying to use unsupported features will throw an error. For more information, see:\n\t *\n\t * https://expressive-code.com/key-features/syntax-highlighting/#transformers\n\t */\n\ttransformers?: ShikiTransformer[] | unknown[] | undefined\n\t/**\n\t * The RegExp engine to use for syntax highlighting.\n\t *\n\t * - `'oniguruma'`: The default engine that supports all grammars,\n\t *   but requires WebAssembly support.\n\t * - `'javascript'`: A pure JavaScript engine that does not require WebAssembly.\n\t */\n\tengine?: 'oniguruma' | 'javascript' | undefined\n}\n\n/**\n * A list of all themes bundled with Shiki.\n */\nexport type BundledShikiTheme = Exclude<keyof typeof bundledThemes, 'css-variables'>\n\n/**\n * A list of all languages bundled with Shiki.\n */\nexport type { BundledLanguage as BundledShikiLanguage } from 'shiki'\n\n/**\n * Loads a theme bundled with Shiki for use with Expressive Code.\n */\nexport async function loadShikiTheme(bundledThemeName: BundledShikiTheme) {\n\tconst shikiTheme = (await bundledThemes[bundledThemeName]()).default\n\treturn new ExpressiveCodeTheme(shikiTheme)\n}\n\n// Workaround: Shiki exports this as an ambient enum, which throws an error when trying to\n// access its values at runtime, so we're defining it ourselves here as a regular enum.\nenum FontStyle {\n\tNotSet = -1,\n\tNone = 0,\n\tItalic = 1,\n\tBold = 2,\n\tUnderline = 4,\n\tStrikethrough = 8,\n}\n\nexport function pluginShiki(options: PluginShikiOptions = {}): ExpressiveCodePlugin {\n\tconst { langs, langAlias = {}, injectLangsIntoNestedCodeBlocks, engine } = options\n\n\t// Validate all configured transformers\n\tvalidateTransformers(options)\n\n\treturn {\n\t\tname: 'Shiki',\n\t\thooks: {\n\t\t\tperformSyntaxAnalysis: async ({ codeBlock, styleVariants, config: { logger } }) => {\n\t\t\t\tconst codeLines = codeBlock.getLines()\n\t\t\t\tlet code = codeBlock.code\n\n\t\t\t\t// If the code block uses a terminal language and includes placeholder strings\n\t\t\t\t// in angle brackets (e.g. `<username>`), Shiki will treat the closing `>` as\n\t\t\t\t// a redirect operator and highlight the character before it differently.\n\t\t\t\t// We work around this by replacing the brackets around such placeholder strings\n\t\t\t\t// with different characters that Shiki will not interpret as operators.\n\t\t\t\tif (isTerminalLanguage(codeBlock.language)) {\n\t\t\t\t\tcode = code.replace(/<([^>]*[^>\\s])>/g, 'X$1X')\n\t\t\t\t}\n\n\t\t\t\tlet highlighter\n\t\t\t\ttry {\n\t\t\t\t\thighlighter = await getCachedHighlighter({ langs, langAlias, injectLangsIntoNestedCodeBlocks, engine })\n\t\t\t\t} catch (err) {\n\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\tconst error = err instanceof Error ? err : new Error(String(err))\n\t\t\t\t\tthrow new Error(`Failed to load syntax highlighter. Please ensure that the configured langs are supported by Shiki.\\nReceived error message: \"${error.message}\"`, {\n\t\t\t\t\t\tcause: error,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t// Try to load the language if necessary, and log a warning if it's is unknown\n\t\t\t\tconst languageLoadErrors = await ensureLanguagesAreLoaded({ highlighter, langs: [codeBlock.language], langAlias })\n\t\t\t\tconst resolvedLanguage = langAlias[codeBlock.language] ?? codeBlock.language\n\t\t\t\tconst primaryLanguageFailed = languageLoadErrors.failedLanguages.has(resolvedLanguage)\n\t\t\t\tconst embeddedLanguagesFailed = languageLoadErrors.failedEmbeddedLanguages.size > 0\n\t\t\t\tconst loadedLanguageName = primaryLanguageFailed ? 'txt' : resolvedLanguage\n\t\t\t\tif (primaryLanguageFailed || embeddedLanguagesFailed) {\n\t\t\t\t\tconst formatLangs = (langs: Set<string> | string[]) =>\n\t\t\t\t\t\t`language${[...langs].length !== 1 ? 's' : ''} ${[...langs]\n\t\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t\t.map((lang) => `\"${lang}\"`)\n\t\t\t\t\t\t\t.join(', ')}`\n\t\t\t\t\tconst errorParts = [\n\t\t\t\t\t\t`Error while highlighting code block using ${formatLangs([codeBlock.language])} in ${\n\t\t\t\t\t\t\tcodeBlock.parentDocument?.sourceFilePath ? `document \"${codeBlock.parentDocument?.sourceFilePath}\"` : 'markdown/MDX document'\n\t\t\t\t\t\t}.`,\n\t\t\t\t\t]\n\t\t\t\t\tif (primaryLanguageFailed) errorParts.push(`The language could not be found. Using \"${loadedLanguageName}\" instead.`)\n\t\t\t\t\tif (embeddedLanguagesFailed) {\n\t\t\t\t\t\terrorParts.push(`The embedded ${formatLangs(languageLoadErrors.failedEmbeddedLanguages)} could not be found, so highlighting may be incomplete.`)\n\t\t\t\t\t}\n\t\t\t\t\terrorParts.push('Ensure that all required languages are either part of the bundle or custom languages provided in the \"langs\" config option.')\n\t\t\t\t\tlogger.warn(errorParts.join(' '))\n\t\t\t\t}\n\n\t\t\t\tfor (let styleVariantIndex = 0; styleVariantIndex < styleVariants.length; styleVariantIndex++) {\n\t\t\t\t\tconst theme = styleVariants[styleVariantIndex].theme\n\n\t\t\t\t\t// Load theme if necessary\n\t\t\t\t\tconst loadedThemeName = await ensureThemeIsLoaded(highlighter, theme, styleVariants)\n\n\t\t\t\t\t// Run highlighter (by default, without explanations to improve performance)\n\t\t\t\t\tlet tokenLines: ThemedToken[][] = []\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst codeToTokensOptions = {\n\t\t\t\t\t\t\tlang: loadedLanguageName,\n\t\t\t\t\t\t\ttheme: loadedThemeName,\n\t\t\t\t\t\t\tincludeExplanation: false,\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Run preprocess hook of all configured transformers\n\t\t\t\t\t\trunPreprocessHook({ options, code, codeBlock, codeToTokensOptions })\n\n\t\t\t\t\t\tconst codeToTokensBase = highlighter.codeToTokensBase\n\t\t\t\t\t\tawait runHighlighterTask(() => {\n\t\t\t\t\t\t\ttokenLines = codeToTokensBase(code, codeToTokensOptions)\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\t// Run tokens hook of all configured transformers\n\t\t\t\t\t\ttokenLines = runTokensHook({ options, code, codeBlock, codeToTokensOptions, tokenLines })\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tconst error = err instanceof Error ? err : new Error(String(err))\n\t\t\t\t\t\tthrow new Error(`Failed to highlight code block with language \"${codeBlock.language}\" and theme \"${theme.name}\".\\nReceived error message: \"${error.message}\"`, {\n\t\t\t\t\t\t\tcause: error,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenLines.forEach((line, lineIndex) => {\n\t\t\t\t\t\tif (codeBlock.language === 'ansi' && styleVariantIndex === 0) removeAnsiSequencesFromCodeLine(codeLines[lineIndex], line)\n\n\t\t\t\t\t\tlet charIndex = 0\n\t\t\t\t\t\tline.forEach((token) => {\n\t\t\t\t\t\t\tconst tokenLength = token.content.length\n\t\t\t\t\t\t\tconst tokenEndIndex = charIndex + tokenLength\n\t\t\t\t\t\t\tconst fontStyle = token.fontStyle || FontStyle.None\n\t\t\t\t\t\t\tcodeLines[lineIndex]?.addAnnotation(\n\t\t\t\t\t\t\t\tnew InlineStyleAnnotation({\n\t\t\t\t\t\t\t\t\tstyleVariantIndex,\n\t\t\t\t\t\t\t\t\tcolor: token.color || theme.fg,\n\t\t\t\t\t\t\t\t\tbgColor: token.bgColor,\n\t\t\t\t\t\t\t\t\titalic: ((fontStyle & FontStyle.Italic) as FontStyle) === FontStyle.Italic,\n\t\t\t\t\t\t\t\t\tbold: ((fontStyle & FontStyle.Bold) as FontStyle) === FontStyle.Bold,\n\t\t\t\t\t\t\t\t\tunderline: ((fontStyle & FontStyle.Underline) as FontStyle) === FontStyle.Underline,\n\t\t\t\t\t\t\t\t\tstrikethrough: ((fontStyle & FontStyle.Strikethrough) as FontStyle) === FontStyle.Strikethrough,\n\t\t\t\t\t\t\t\t\tinlineRange: {\n\t\t\t\t\t\t\t\t\t\tcolumnStart: charIndex,\n\t\t\t\t\t\t\t\t\t\tcolumnEnd: tokenEndIndex,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trenderPhase: 'earliest',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tcharIndex = tokenEndIndex\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunction isTerminalLanguage(language: string) {\n\treturn ['shellscript', 'shell', 'bash', 'sh', 'zsh', 'nu', 'nushell'].includes(language)\n}\n\n/**\n * Removes ANSI sequences processed by Shiki from the provided codeline\n */\nfunction removeAnsiSequencesFromCodeLine(codeLine: ExpressiveCodeLine, lineTokens: ThemedToken[]): void {\n\t// The provided tokens from Shiki will already be stripped for control characters\n\tconst newLine = lineTokens.map((token) => token.content).join('')\n\t// Removing sequences by ranges instead of whole line to avoid breaking any existing annotations\n\tconst rangesToRemove = getRemovedRanges(codeLine.text, newLine)\n\tfor (let index = rangesToRemove.length - 1; index >= 0; index--) {\n\t\tconst [start, end] = rangesToRemove[index]\n\t\tcodeLine.editText(start, end, '')\n\t}\n}\n\n/**\n * Compares a given `original` string to its `edited` version, assuming that the only kind of edits\n * allowed between them is the removal of column ranges from the original string.\n *\n * Returns an array of column ranges that were removed from the original string.\n */\nfunction getRemovedRanges(original: string, edited: string): [start: number, end: number][] {\n\tconst ranges: [start: number, ends: number][] = []\n\tlet from = -1\n\tlet orgIdx = 0\n\tlet edtIdx = 0\n\n\twhile (orgIdx < original.length && edtIdx < edited.length) {\n\t\tif (original[orgIdx] !== edited[edtIdx]) {\n\t\t\tif (from === -1) from = orgIdx\n\t\t\torgIdx++\n\t\t} else {\n\t\t\tif (from > -1) {\n\t\t\t\tranges.push([from, orgIdx])\n\t\t\t\tfrom = -1\n\t\t\t}\n\t\t\torgIdx++\n\t\t\tedtIdx++\n\t\t}\n\t}\n\n\tif (edtIdx < edited.length) throw new Error(`Edited string contains characters not present in original (${JSON.stringify({ original, edited })})`)\n\n\tif (orgIdx < original.length) ranges.push([orgIdx, original.length])\n\n\treturn ranges\n}\n","import type { StyleVariant } from '@expressive-code/core'\nimport { ExpressiveCodeTheme, getStableObjectHash } from '@expressive-code/core'\nimport type { BundledLanguage, HighlighterCore, ThemeRegistration } from 'shiki'\nimport { bundledLanguages, createHighlighterCore, isSpecialLang } from 'shiki'\nimport type { LanguageInput, LanguageRegistration, ShikiLanguageRegistration } from './languages'\nimport { getNestedCodeBlockInjectionLangs } from './languages'\nimport type { PluginShikiOptions } from '.'\n\nconst highlighterPromiseByConfig = new Map<string, Promise<HighlighterCore>>()\n// We store theme cache keys by style variant arrays because style variant arrays are unique per engine,\n// and we can be confident that the same theme object used by the same engine has the same contents\nconst themeCacheKeysByStyleVariants = new WeakMap<StyleVariant[], WeakMap<ExpressiveCodeTheme, string>>()\n\n/**\n * Gets a cached Shiki highlighter instance for the given configuration.\n */\nexport async function getCachedHighlighter(config: PluginShikiOptions = {}): Promise<HighlighterCore> {\n\tconst configCacheKey = getStableObjectHash(config)\n\tlet highlighterPromise = highlighterPromiseByConfig.get(configCacheKey)\n\tif (highlighterPromise === undefined) {\n\t\thighlighterPromise = (async () => {\n\t\t\tconst highlighter = await createHighlighterCore({\n\t\t\t\tthemes: [],\n\t\t\t\tlangs: [],\n\t\t\t\tengine: createRegexEngine(config.engine),\n\t\t\t})\n\t\t\t// Load any user-provided languages\n\t\t\tawait ensureLanguagesAreLoaded({ highlighter, ...config })\n\t\t\treturn highlighter\n\t\t})()\n\t\thighlighterPromiseByConfig.set(configCacheKey, highlighterPromise)\n\t}\n\treturn highlighterPromise\n}\n\nasync function createRegexEngine(engine: PluginShikiOptions['engine']) {\n\t// The [...engine...][0] syntax makes it easier to find this code in the built package,\n\t// allowing astro-expressive-code to remove unused engines from the SSR bundle\n\tif (engine === 'javascript') return [(await import('shiki/engine/javascript')).createJavaScriptRegexEngine({ forgiving: true })][0]\n\treturn [(await import('shiki/engine/oniguruma')).createOnigurumaEngine(import('shiki/wasm'))][0]\n}\n\nexport async function ensureThemeIsLoaded(highlighter: HighlighterCore, theme: ExpressiveCodeTheme, styleVariants: StyleVariant[]) {\n\t// Unfortunately, Shiki caches themes by name, so we need to ensure that the theme name changes\n\t// whenever the theme contents change by appending a content hash\n\tlet themeCacheKeys = themeCacheKeysByStyleVariants.get(styleVariants)\n\tif (!themeCacheKeys) {\n\t\tthemeCacheKeys = new WeakMap<ExpressiveCodeTheme, string>()\n\t\tthemeCacheKeysByStyleVariants.set(styleVariants, themeCacheKeys)\n\t}\n\tconst existingCacheKey = themeCacheKeys.get(theme)\n\tconst cacheKey = existingCacheKey ?? `${theme.name}-${getStableObjectHash({ bg: theme.bg, fg: theme.fg, settings: theme.settings })}`\n\tif (!existingCacheKey) themeCacheKeys.set(theme, cacheKey)\n\n\tawait runHighlighterTask(async () => {\n\t\t// Only load the theme if it hasn't been loaded yet\n\t\tif (highlighter.getLoadedThemes().includes(cacheKey)) return\n\t\tconst themeUsingCacheKey = { ...theme, name: cacheKey, settings: (theme.settings as ThemeRegistration['settings']) ?? [] }\n\t\tawait highlighter.loadTheme(themeUsingCacheKey)\n\t})\n\treturn cacheKey\n}\n\nexport async function ensureLanguagesAreLoaded(options: Omit<PluginShikiOptions, 'langs'> & { highlighter: HighlighterCore; langs?: (LanguageInput | string)[] | undefined }) {\n\tconst { highlighter, langs = [], langAlias = {}, injectLangsIntoNestedCodeBlocks } = options\n\tconst failedLanguages = new Set<string>()\n\tconst failedEmbeddedLanguages = new Set<string>()\n\n\tif (!langs.length) return { failedLanguages, failedEmbeddedLanguages }\n\n\tawait runHighlighterTask(async () => {\n\t\tconst loadedLanguages = new Set(highlighter.getLoadedLanguages())\n\t\tconst handledLanguageNames = new Set<string>()\n\t\tconst registrations = new Map<string, LanguageRegistration>()\n\n\t\tasync function resolveLanguage(language: LanguageInput | string, isEmbedded = false) {\n\t\t\tlet languageInput: LanguageInput\n\t\t\t// Retrieve the language input of named languages if necessary\n\t\t\tif (typeof language === 'string') {\n\t\t\t\t// Resolve language aliases\n\t\t\t\tlanguage = langAlias[language] ?? language\n\t\t\t\t// Skip if we already handled this language\n\t\t\t\tif (handledLanguageNames.has(language)) return []\n\t\t\t\thandledLanguageNames.add(language)\n\t\t\t\t// Skip if the language doesn't need to be loaded\n\t\t\t\tif (loadedLanguages.has(language) || isSpecialLang(language)) return []\n\t\t\t\t// We can't resolve named languages we don't know\n\t\t\t\tif (!Object.keys(bundledLanguages).includes(language)) {\n\t\t\t\t\tif (isEmbedded) {\n\t\t\t\t\t\tfailedEmbeddedLanguages.add(language)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfailedLanguages.add(language)\n\t\t\t\t\t}\n\t\t\t\t\treturn []\n\t\t\t\t}\n\t\t\t\tlanguageInput = bundledLanguages[language as BundledLanguage]\n\t\t\t} else {\n\t\t\t\tlanguageInput = language\n\t\t\t}\n\t\t\t// Resolve the language input to an array of language registrations\n\t\t\tconst potentialModule = await Promise.resolve(typeof languageInput === 'function' ? languageInput() : languageInput)\n\t\t\tconst potentialArray = 'default' in potentialModule ? potentialModule.default : potentialModule\n\t\t\tconst languageRegistrations = Array.isArray(potentialArray) ? potentialArray : [potentialArray]\n\t\t\tlanguageRegistrations.forEach((lang) => {\n\t\t\t\tif (loadedLanguages.has(lang.name)) return\n\t\t\t\t// Prevent Shiki from executing its lazy-loading logic\n\t\t\t\t// as we load any referenced languages ourselves\n\t\t\t\tconst registration = { repository: {}, ...lang, embeddedLangsLazy: [] } as LanguageRegistration\n\t\t\t\tregistrations.set(lang.name, registration)\n\t\t\t})\n\t\t\t// Inject top-level languages into nested code blocks if enabled\n\t\t\tif (injectLangsIntoNestedCodeBlocks && !isEmbedded) {\n\t\t\t\tlanguageRegistrations.forEach((lang) => {\n\t\t\t\t\tconst injectionLangs = getNestedCodeBlockInjectionLangs(lang, langAlias)\n\t\t\t\t\tinjectionLangs.forEach((injectionLang) => registrations.set(injectionLang.name, injectionLang))\n\t\t\t\t})\n\t\t\t}\n\t\t\t// Recursively resolve embedded languages\n\t\t\tconst referencedLangs = [...new Set(languageRegistrations.map((lang) => lang.embeddedLangsLazy ?? []).flat())] as BundledLanguage[]\n\t\t\tawait Promise.all(referencedLangs.map((lang) => resolveLanguage(lang, true)))\n\t\t}\n\n\t\tawait Promise.all(langs.map((lang) => resolveLanguage(lang)))\n\n\t\tif (registrations.size) await highlighter.loadLanguage(...([...registrations.values()] as ShikiLanguageRegistration[]))\n\t})\n\n\treturn { failedLanguages, failedEmbeddedLanguages }\n}\n\nconst taskQueue: { taskFn: () => void | Promise<void>; resolve: () => void; reject: (error: unknown) => void }[] = []\nlet processingQueue = false\n\n/**\n * Runs a task in the mutually exclusive highlighter task queue. Ensuring sequential execution\n * of highlighter operations prevents race conditions caused by lazy-loading of languages.\n */\nexport function runHighlighterTask(taskFn: () => void | Promise<void>): Promise<void> {\n\treturn new Promise<void>((resolve, reject) => {\n\t\ttaskQueue.push({ taskFn, resolve, reject })\n\t\tif (!processingQueue) {\n\t\t\tprocessingQueue = true\n\t\t\tprocessQueue().catch((error) => {\n\t\t\t\tprocessingQueue = false\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.error('Error in Shiki highlighter task queue:', error)\n\t\t\t})\n\t\t}\n\t})\n}\n\nasync function processQueue() {\n\ttry {\n\t\twhile (taskQueue.length > 0) {\n\t\t\tconst task = taskQueue.shift()\n\t\t\tif (!task) break\n\t\t\tconst { taskFn, resolve, reject } = task\n\t\t\ttry {\n\t\t\t\tawait taskFn()\n\t\t\t\tresolve()\n\t\t\t} catch (error) {\n\t\t\t\treject(error)\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tprocessingQueue = false\n\t}\n}\n","import type { LanguageRegistration as ShikiLanguageRegistration, MaybeGetter, MaybeArray } from 'shiki'\n\n// Extract or rebuild non-exported types from Shiki\ntype IShikiRawRepository = ShikiLanguageRegistration['repository']\ntype IShikiRawRule = IShikiRawRepository[keyof IShikiRawRepository]\ntype ILocation = IShikiRawRepository['$vscodeTextmateLocation']\ninterface ILocatable {\n\treadonly $vscodeTextmateLocation?: ILocation | undefined\n}\n\n// Define modified versions of internal Shiki types that use our less strict `IRawRule`\ninterface IRawRepositoryMap {\n\t[name: string]: IRawRule\n}\ntype IRawRepository = IRawRepositoryMap & ILocatable\ninterface IRawCapturesMap {\n\t[captureId: string]: IRawRule\n}\ntype IRawCaptures = IRawCapturesMap & ILocatable\n\n// Create our less strict version of Shiki's internal `IRawRule` interface\ninterface IRawRule extends Omit<IShikiRawRule, 'applyEndPatternLast' | 'captures' | 'patterns'> {\n\treadonly applyEndPatternLast?: boolean | number | undefined\n\treadonly captures?: IRawCaptures | undefined\n\treadonly comment?: string | undefined\n\treadonly patterns?: IRawRule[] | undefined\n}\n\n/**\n * A less strict version of Shiki's `LanguageRegistration` interface that aligns better with\n * actual grammars found in the wild. This version attempts to reduce the amount\n * of type errors that would occur when importing and adding external grammars,\n * while still being supported by the language processing code.\n */\nexport interface LanguageRegistration extends Omit<ShikiLanguageRegistration, 'repository'> {\n\trepository?: IRawRepository | undefined\n}\n\nexport type LanguageInput = MaybeGetter<MaybeArray<LanguageRegistration>>\n\nexport { ShikiLanguageRegistration }\n\n/**\n * Creates a set of language registrations that inject the given language into\n * Markdown and MDX fenced code blocks.\n */\nexport function getNestedCodeBlockInjectionLangs(lang: LanguageRegistration, langAlias: Record<string, string> = {}) {\n\tconst injectionLangs: LanguageRegistration[] = []\n\tconst langNameKey = lang.name.replace(/[^a-zA-Z0-9]/g, '_')\n\tconst langNameAndAliases = [lang.name, ...(lang.aliases ?? [])]\n\t// Add user-configured aliases for the current lang (if any)\n\tObject.entries(langAlias).forEach(([alias, target]) => {\n\t\tif (target === lang.name && !langNameAndAliases.includes(alias)) langNameAndAliases.push(alias)\n\t})\n\n\t// Create injection language registration for Markdown\n\tinjectionLangs.push({\n\t\tname: `${lang.name}-fenced-md`,\n\t\tscopeName: `source.${lang.name}.fenced_code_block`,\n\t\tinjectTo: ['text.html.markdown'],\n\t\tinjectionSelector: 'L:text.html.markdown',\n\t\tpatterns: [\n\t\t\t{\n\t\t\t\tinclude: `#fenced_code_block_${langNameKey}`,\n\t\t\t},\n\t\t],\n\t\trepository: {\n\t\t\t[`fenced_code_block_${langNameKey}`]: {\n\t\t\t\tbegin: `(^|\\\\G)(\\\\s*)(\\`{3,}|~{3,})\\\\s*(?i:(${langNameAndAliases.join('|')})((\\\\s+|:|,|\\\\{|\\\\?)[^\\`]*)?$)`,\n\t\t\t\tbeginCaptures: {\n\t\t\t\t\t3: {\n\t\t\t\t\t\tname: 'punctuation.definition.markdown',\n\t\t\t\t\t},\n\t\t\t\t\t4: {\n\t\t\t\t\t\tname: 'fenced_code.block.language.markdown',\n\t\t\t\t\t},\n\t\t\t\t\t5: {\n\t\t\t\t\t\tname: 'fenced_code.block.language.attributes.markdown',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tend: '(^|\\\\G)(\\\\2|\\\\s{0,3})(\\\\3)\\\\s*$',\n\t\t\t\tendCaptures: {\n\t\t\t\t\t3: {\n\t\t\t\t\t\tname: 'punctuation.definition.markdown',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tname: 'markup.fenced_code.block.markdown',\n\t\t\t\tpatterns: [\n\t\t\t\t\t{\n\t\t\t\t\t\tbegin: '(^|\\\\G)(\\\\s*)(.*)',\n\t\t\t\t\t\twhile: '(^|\\\\G)(?!\\\\s*([`~]{3,})\\\\s*$)',\n\t\t\t\t\t\tcontentName: `meta.embedded.block.${lang.name}`,\n\t\t\t\t\t\tpatterns: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinclude: lang.scopeName,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t},\n\t})\n\n\t// Create injection language registration for MDX\n\tinjectionLangs.push({\n\t\tname: `${lang.name}-fenced-mdx`,\n\t\tscopeName: `source.${lang.name}.fenced_code_block`,\n\t\tinjectTo: ['source.mdx'],\n\t\tinjectionSelector: 'L:source.mdx',\n\t\tpatterns: [\n\t\t\t{\n\t\t\t\tinclude: `#fenced_code_block_${langNameKey}`,\n\t\t\t},\n\t\t],\n\t\trepository: {\n\t\t\t[`fenced_code_block_${langNameKey}`]: {\n\t\t\t\tbegin: `(?:^|\\\\G)[\\\\t ]*(\\`{3,})(?:[\\\\t ]*((?i:(?:.*\\\\.)?${langNameAndAliases.join('|')}))(?:[\\\\t ]+((?:[^\\\\n\\\\r\\`])+))?)(?:[\\\\t ]*$)`,\n\t\t\t\tbeginCaptures: {\n\t\t\t\t\t1: {\n\t\t\t\t\t\tname: 'string.other.begin.code.fenced.mdx',\n\t\t\t\t\t},\n\t\t\t\t\t2: {\n\t\t\t\t\t\tname: 'entity.name.function.mdx',\n\t\t\t\t\t\tpatterns: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinclude: '#markdown-string',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t3: {\n\t\t\t\t\t\tpatterns: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinclude: '#markdown-string',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tend: '(?:^|\\\\G)[\\\\t ]*(\\\\1)(?:[\\\\t ]*$)',\n\t\t\t\tendCaptures: {\n\t\t\t\t\t1: {\n\t\t\t\t\t\tname: 'string.other.end.code.fenced.mdx',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tname: `markup.code.${lang.name}.mdx`,\n\t\t\t\tpatterns: [\n\t\t\t\t\t{\n\t\t\t\t\t\tbegin: '(^|\\\\G)(\\\\s*)(.*)',\n\t\t\t\t\t\tcontentName: `meta.embedded.${lang.name}`,\n\t\t\t\t\t\tpatterns: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinclude: lang.scopeName,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t\twhile: '(^|\\\\G)(?![\\\\t ]*([`~]{3,})[\\\\t ]*$)',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t},\n\t})\n\n\treturn injectionLangs\n}\n","import { ExpressiveCodeBlock } from '@expressive-code/core'\nimport type { PluginShikiOptions } from '.'\nimport type { CodeToHastOptions, ShikiTransformer, ShikiTransformerContextSource, ThemedToken } from 'shiki'\n\nexport type BaseHookArgs = {\n\toptions: PluginShikiOptions\n\tcode: string\n\tcodeBlock: ExpressiveCodeBlock\n\tcodeToTokensOptions: CodeToHastOptions\n}\n\n/**\n * Throws an error if any of the configured transformers use unsupported hooks.\n */\nexport function validateTransformers(options: PluginShikiOptions) {\n\tif (!options.transformers) return\n\tconst unsupportedTransformerHooks: (keyof ShikiTransformer)[] = ['code', 'line', 'postprocess', 'pre', 'root', 'span']\n\tfor (const transformer of coerceTransformers(options.transformers)) {\n\t\tconst unsupportedHook = unsupportedTransformerHooks.find((hook) => transformer[hook] != null)\n\t\tif (unsupportedHook) {\n\t\t\tthrow new ExpressiveCodeShikiTransformerError(transformer, `The transformer hook \"${unsupportedHook}\" is not supported by Expressive Code yet.`)\n\t\t}\n\t}\n}\n\nexport function runPreprocessHook(args: BaseHookArgs) {\n\tconst { options, code, codeBlock, codeToTokensOptions } = args\n\tcoerceTransformers(options.transformers).forEach((transformer) => {\n\t\tif (!transformer.preprocess) return\n\t\tconst transformerContext = getTransformerContext({ transformer, code, codeBlock, codeToTokensOptions })\n\t\tconst transformedCode = transformer.preprocess.call(transformerContext, code, codeToTokensOptions)\n\t\tif (typeof transformedCode === 'string' && transformedCode !== code) {\n\t\t\tthrow new ExpressiveCodeShikiTransformerError(transformer, `Transformers that modify code in the \"preprocess\" hook are not supported yet.`)\n\t\t}\n\t})\n}\n\nexport function runTokensHook(args: BaseHookArgs & { tokenLines: ThemedToken[][] }) {\n\tconst { options, code, codeBlock, codeToTokensOptions } = args\n\tconst originalTokenLinesText = getTokenLinesText(args.tokenLines)\n\tcoerceTransformers(options.transformers).forEach((transformer) => {\n\t\tif (!transformer.tokens) return\n\t\tconst transformerContext = getTransformerContext({ transformer, code, codeBlock, codeToTokensOptions })\n\t\tconst transformedTokenLines = transformer.tokens.call(transformerContext, args.tokenLines)\n\t\t// Transformers can either mutate the tokens in place,\n\t\t// or return a new array of tokens\n\t\tif (transformedTokenLines) {\n\t\t\targs.tokenLines = transformedTokenLines\n\t\t}\n\t\t// Ensure that the transformer didn't change the text contents of the tokens\n\t\tconst newTokenLinesText = getTokenLinesText(args.tokenLines)\n\t\tif (originalTokenLinesText.length !== args.tokenLines.length) {\n\t\t\tthrow new ExpressiveCodeShikiTransformerError(\n\t\t\t\ttransformer,\n\t\t\t\t`Transformers that modify code in the \"tokens\" hook are not supported yet. The number of lines changed from ${originalTokenLinesText.length} to ${args.tokenLines.length}.`\n\t\t\t)\n\t\t}\n\t\tfor (let i = 0; i < newTokenLinesText.length; i++) {\n\t\t\tif (originalTokenLinesText[i] !== newTokenLinesText[i]) {\n\t\t\t\tthrow new ExpressiveCodeShikiTransformerError(\n\t\t\t\t\ttransformer,\n\t\t\t\t\t`Transformers that modify code in the \"tokens\" hook are not supported yet. Line ${i + 1} changed from \"${originalTokenLinesText[i]}\" to \"${newTokenLinesText[i]}\".`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t})\n\treturn args.tokenLines\n}\n\n/**\n * To circumvent breaking changes in the Shiki transformer API\n * that we don't support anyway, we accept unknown transformers\n * and coerce them to ShikiTransformer.\n */\nfunction coerceTransformers(transformers: (ShikiTransformer | unknown)[] | undefined) {\n\tif (!transformers) return []\n\treturn transformers.map((transformer) => transformer as ShikiTransformer)\n}\n\nfunction getTokenLinesText(tokenLines: ThemedToken[][]) {\n\treturn tokenLines.map((line) => line.map((token) => token.content).join(''))\n}\n\nexport function getTransformerContext(contextBase: {\n\ttransformer: ShikiTransformer\n\tcode: string\n\tcodeBlock: ExpressiveCodeBlock\n\tcodeToTokensOptions: CodeToHastOptions\n}): ShikiTransformerContextSource {\n\tconst { transformer, code, codeBlock, codeToTokensOptions } = contextBase\n\tconst getUnsupportedFnHandler = (name: string) => {\n\t\treturn () => {\n\t\t\tthrow new ExpressiveCodeShikiTransformerError(transformer, `The context function \"${name}\" is not available in Expressive Code transformers yet.`)\n\t\t}\n\t}\n\treturn {\n\t\tsource: code,\n\t\toptions: codeToTokensOptions,\n\t\tmeta: {\n\t\t\t...(Object.fromEntries(codeBlock.metaOptions.list().map((option) => [option.key, option.value])) as Record<string, string | boolean | RegExp>),\n\t\t\t__raw: codeBlock.meta,\n\t\t},\n\t\tcodeToHast: getUnsupportedFnHandler('codeToHast'),\n\t\tcodeToTokens: getUnsupportedFnHandler('codeToTokens'),\n\t}\n}\n\nexport class ExpressiveCodeShikiTransformerError extends Error {\n\tconstructor(transformer: ShikiTransformer, message: string) {\n\t\tsuper(\n\t\t\t`Failed to run Shiki transformer${transformer.name ? ` \"${transformer.name}\"` : ''}: ${message}\n\t\t\t\n\t\t\tIMPORTANT: This is not a bug - neither in Shiki, nor in the transformer or Expressive Code.\n\t\t\tTransformer support in Expressive Code is still experimental and limited to a few cases\n\t\t\t(e.g. transformers that modify syntax highlighting tokens).\n\n\t\t\tTo continue, remove this transformer from the Expressive Code configuration,\n\t\t\tor visit the following link for more information and other options:\n\t\t\thttps://expressive-code.com/key-features/syntax-highlighting/#transformers`\n\t\t\t\t.replace(/^\\t+/gm, '')\n\t\t\t\t.replace(/(?<!\\n)\\n(?!\\n)/g, ' ')\n\t\t)\n\t\tthis.name = 'ExpressiveCodeShikiTransformerError'\n\t}\n}\n"],"mappings":"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","names":["ExpressiveCodeTheme","ExpressiveCodeTheme","langs"]}